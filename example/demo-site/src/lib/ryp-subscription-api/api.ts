/* tslint:disable */
/* eslint-disable */
/**
 * Core Subscription Service
 * The API for the core subscription management service of the Cardano Blockchain announcement and notification application \"Reach Your People\"
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@vibrantnet.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'createTime'?: string;
}
/**
 * 
 * @export
 * @interface AccountPartial
 */
export interface AccountPartial {
    /**
     * 
     * @type {string}
     * @memberof AccountPartial
     */
    'displayName'?: string;
}
/**
 * 
 * @export
 * @interface CreateExternalAccountRequest
 */
export interface CreateExternalAccountRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateExternalAccountRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'registrationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'referenceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'referenceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'displayName'?: string;
    /**
     * Any additional metadata for the external account (like a Push API subscription JSON blob), binary data encoded as base64.
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'metadata'?: string;
}
/**
 * An explicit subscription to a single project and an associated status
 * @export
 * @interface GetAllSubscriptionsForAccount200ResponseInner
 */
export interface GetAllSubscriptionsForAccount200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetAllSubscriptionsForAccount200ResponseInner
     */
    'projectId': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllSubscriptionsForAccount200ResponseInner
     */
    'status': GetAllSubscriptionsForAccount200ResponseInnerStatusEnum;
}

export const GetAllSubscriptionsForAccount200ResponseInnerStatusEnum = {
    Subscribed: 'SUBSCRIBED',
    Blocked: 'BLOCKED'
} as const;

export type GetAllSubscriptionsForAccount200ResponseInnerStatusEnum = typeof GetAllSubscriptionsForAccount200ResponseInnerStatusEnum[keyof typeof GetAllSubscriptionsForAccount200ResponseInnerStatusEnum];

/**
 * An explicit subscription to a single project and an associated status
 * @export
 * @interface GetAllSubscriptionsForProject200ResponseInner
 */
export interface GetAllSubscriptionsForProject200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetAllSubscriptionsForProject200ResponseInner
     */
    'projectId': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllSubscriptionsForProject200ResponseInner
     */
    'status': GetAllSubscriptionsForProject200ResponseInnerStatusEnum;
}

export const GetAllSubscriptionsForProject200ResponseInnerStatusEnum = {
    Subscribed: 'SUBSCRIBED',
    Blocked: 'BLOCKED'
} as const;

export type GetAllSubscriptionsForProject200ResponseInnerStatusEnum = typeof GetAllSubscriptionsForProject200ResponseInnerStatusEnum[keyof typeof GetAllSubscriptionsForProject200ResponseInnerStatusEnum];

/**
 * 
 * @export
 * @interface GetGlobalSubscriptions200ResponseInner
 */
export interface GetGlobalSubscriptions200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'id'?: number;
    /**
     * A project ID or empty, if explicitly subscribed to everything
     * @type {number}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'status': GetGlobalSubscriptions200ResponseInnerStatusEnum;
    /**
     * Referenced Account ID that owns this subscription setting
     * @type {number}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'accountId': number;
}

export const GetGlobalSubscriptions200ResponseInnerStatusEnum = {
    Subscribed: 'SUBSCRIBED',
    Blocked: 'BLOCKED'
} as const;

export type GetGlobalSubscriptions200ResponseInnerStatusEnum = typeof GetGlobalSubscriptions200ResponseInnerStatusEnum[keyof typeof GetGlobalSubscriptions200ResponseInnerStatusEnum];

/**
 * 
 * @export
 * @interface GetLinkedExternalAccounts200ResponseInner
 */
export interface GetLinkedExternalAccounts200ResponseInner {
    /**
     * 
     * @type {CreateExternalAccountRequest}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'externalAccount': CreateExternalAccountRequest;
    /**
     * 
     * @type {string}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'role': GetLinkedExternalAccounts200ResponseInnerRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'linkTime': string;
}

export const GetLinkedExternalAccounts200ResponseInnerRoleEnum = {
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Publisher: 'PUBLISHER',
    Subscriber: 'SUBSCRIBER'
} as const;

export type GetLinkedExternalAccounts200ResponseInnerRoleEnum = typeof GetLinkedExternalAccounts200ResponseInnerRoleEnum[keyof typeof GetLinkedExternalAccounts200ResponseInnerRoleEnum];

/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInner
 */
export interface GetProjectsForAccount200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'category'?: GetProjectsForAccount200ResponseInnerCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'registrationTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'verified'?: boolean;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerDrepsInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'dreps'?: Array<GetProjectsForAccount200ResponseInnerDrepsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'stakepools'?: Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerPoliciesInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'policies'?: Array<GetProjectsForAccount200ResponseInnerPoliciesInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerSocialsInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'socials'?: Array<GetProjectsForAccount200ResponseInnerSocialsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'wallets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    ''?: string;
}

export const GetProjectsForAccount200ResponseInnerCategoryEnum = {
    DeFi: 'DeFi',
    Nft: 'NFT',
    Spo: 'SPO',
    DRep: 'dRep',
    Dao: 'DAO',
    Other: 'Other'
} as const;

export type GetProjectsForAccount200ResponseInnerCategoryEnum = typeof GetProjectsForAccount200ResponseInnerCategoryEnum[keyof typeof GetProjectsForAccount200ResponseInnerCategoryEnum];

/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerDrepsInner
 */
export interface GetProjectsForAccount200ResponseInnerDrepsInner {
    /**
     * 
     * @type {number}
     * @memberof GetProjectsForAccount200ResponseInnerDrepsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerDrepsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerDrepsInner
     */
    'drepId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerDrepsInner
     */
    'bech32'?: string;
}
/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerPoliciesInner
 */
export interface GetProjectsForAccount200ResponseInnerPoliciesInner {
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerPoliciesInner
     */
    'name'?: string;
    /**
     * The Policy ID
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerPoliciesInner
     */
    'policyId'?: string;
}
/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerSocialsInner
 */
export interface GetProjectsForAccount200ResponseInnerSocialsInner {
    /**
     * 
     * @type {number}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'referenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'referenceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'type'?: GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum;
}

export const GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum = {
    Twitter: 'TWITTER',
    Discord: 'DISCORD'
} as const;

export type GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum = typeof GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum[keyof typeof GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum];

/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerStakepoolsInner
 */
export interface GetProjectsForAccount200ResponseInnerStakepoolsInner {
    /**
     * 
     * @type {number}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'ticker'?: string;
    /**
     * The Stakepool hash
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'poolId'?: string;
    /**
     * The pool ID of a wallet, in viewable Bech32 format
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'bech32'?: string;
}
/**
 * 
 * @export
 * @interface LinkExternalAccount200Response
 */
export interface LinkExternalAccount200Response {
    /**
     * 
     * @type {CreateExternalAccountRequest}
     * @memberof LinkExternalAccount200Response
     */
    'externalAccount': CreateExternalAccountRequest;
    /**
     * 
     * @type {string}
     * @memberof LinkExternalAccount200Response
     */
    'role': LinkExternalAccount200ResponseRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof LinkExternalAccount200Response
     */
    'linkTime': string;
}

export const LinkExternalAccount200ResponseRoleEnum = {
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Publisher: 'PUBLISHER',
    Subscriber: 'SUBSCRIBER'
} as const;

export type LinkExternalAccount200ResponseRoleEnum = typeof LinkExternalAccount200ResponseRoleEnum[keyof typeof LinkExternalAccount200ResponseRoleEnum];

/**
 * 
 * @export
 * @interface ListProjects200Response
 */
export interface ListProjects200Response {
    /**
     * 
     * @type {number}
     * @memberof ListProjects200Response
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'category'?: ListProjects200ResponseCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListProjects200Response
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'registrationTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListProjects200Response
     */
    'verified'?: boolean;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerDrepsInner>}
     * @memberof ListProjects200Response
     */
    'dreps'?: Array<GetProjectsForAccount200ResponseInnerDrepsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>}
     * @memberof ListProjects200Response
     */
    'stakepools'?: Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerPoliciesInner>}
     * @memberof ListProjects200Response
     */
    'policies'?: Array<GetProjectsForAccount200ResponseInnerPoliciesInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerSocialsInner>}
     * @memberof ListProjects200Response
     */
    'socials'?: Array<GetProjectsForAccount200ResponseInnerSocialsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListProjects200Response
     */
    'wallets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    ''?: string;
}

export const ListProjects200ResponseCategoryEnum = {
    DeFi: 'DeFi',
    Nft: 'NFT',
    Spo: 'SPO',
    DRep: 'dRep',
    Dao: 'DAO',
    Other: 'Other'
} as const;

export type ListProjects200ResponseCategoryEnum = typeof ListProjects200ResponseCategoryEnum[keyof typeof ListProjects200ResponseCategoryEnum];

/**
 * 
 * @export
 * @interface SubscribeAccountToProjectRequest
 */
export interface SubscribeAccountToProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscribeAccountToProjectRequest
     */
    'status': SubscribeAccountToProjectRequestStatusEnum;
}

export const SubscribeAccountToProjectRequestStatusEnum = {
    Subscribed: 'SUBSCRIBED',
    Blocked: 'BLOCKED'
} as const;

export type SubscribeAccountToProjectRequestStatusEnum = typeof SubscribeAccountToProjectRequestStatusEnum[keyof typeof SubscribeAccountToProjectRequestStatusEnum];


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new project
         * @param {ListProjects200Response} listProjects200Response 
         * @param {number} [projectOwner] Account ID of the owner of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewProject: async (listProjects200Response: ListProjects200Response, projectOwner?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listProjects200Response' is not null or undefined
            assertParamExists('addNewProject', 'listProjects200Response', listProjects200Response)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectOwner !== undefined) {
                localVarQueryParameter['projectOwner'] = projectOwner;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listProjects200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new account.
         * @summary Create New Account
         * @param {Account} account Post the necessary fields for the API to create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (account: Account, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('createAccount', 'account', account)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(account, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create External Account
         * @param {CreateExternalAccountRequest} createExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalAccount: async (createExternalAccountRequest: CreateExternalAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createExternalAccountRequest' is not null or undefined
            assertParamExists('createExternalAccount', 'createExternalAccountRequest', createExternalAccountRequest)
            const localVarPath = `/externalaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExternalAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
         * @summary Find Account by External Account Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountByProviderAndReferenceId: async (providerType: string, referenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerType' is not null or undefined
            assertParamExists('findAccountByProviderAndReferenceId', 'providerType', providerType)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('findAccountByProviderAndReferenceId', 'referenceId', referenceId)
            const localVarPath = `/accounts/{providerType}/{referenceId}`
                .replace(`{${"providerType"}}`, encodeURIComponent(String(providerType)))
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
         * @summary Find External Account by Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExternalAccountByProviderAndReferenceId: async (providerType: string, referenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerType' is not null or undefined
            assertParamExists('findExternalAccountByProviderAndReferenceId', 'providerType', providerType)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('findExternalAccountByProviderAndReferenceId', 'referenceId', referenceId)
            const localVarPath = `/externalaccounts/{providerType}/{referenceId}`
                .replace(`{${"providerType"}}`, encodeURIComponent(String(providerType)))
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of the account with the matching account ID.
         * @summary Get Account Info by numeric ID
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountById', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all subscriptions for an account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAllSubscriptionsForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/subscriptions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all subscriptions for a project
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForProject: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAllSubscriptionsForProject', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/subscriptions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
         * @summary Get global subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSubscriptions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions/global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Show linked external accounts
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedExternalAccounts: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getLinkedExternalAccounts', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/externalaccounts`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all projects that this account is an owner of.
         * @summary Get projects owned by this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getProjectsForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/projects`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links an existing external account to this account (if possible)
         * @summary Link existing external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkExternalAccount: async (accountId: number, externalAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('linkExternalAccount', 'accountId', accountId)
            // verify required parameter 'externalAccountId' is not null or undefined
            assertParamExists('linkExternalAccount', 'externalAccountId', externalAccountId)
            const localVarPath = `/accounts/{accountId}/externalaccounts/{externalAccountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"externalAccountId"}}`, encodeURIComponent(String(externalAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add explicit subscription for this account and this project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeAccountToProject: async (accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('subscribeAccountToProject', 'accountId', accountId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('subscribeAccountToProject', 'projectId', projectId)
            // verify required parameter 'subscribeAccountToProjectRequest' is not null or undefined
            assertParamExists('subscribeAccountToProject', 'subscribeAccountToProjectRequest', subscribeAccountToProjectRequest)
            const localVarPath = `/accounts/{accountId}/subscriptions/projects/{projectId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeAccountToProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlink the external account from this account
         * @summary Unlink external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkExternalAccount: async (accountId: number, externalAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('unlinkExternalAccount', 'accountId', accountId)
            // verify required parameter 'externalAccountId' is not null or undefined
            assertParamExists('unlinkExternalAccount', 'externalAccountId', externalAccountId)
            const localVarPath = `/accounts/{accountId}/externalaccounts/{externalAccountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"externalAccountId"}}`, encodeURIComponent(String(externalAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove explicit subscription for this account and project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeAccountFromProject: async (accountId: number, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('unsubscribeAccountFromProject', 'accountId', accountId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unsubscribeAccountFromProject', 'projectId', projectId)
            const localVarPath = `/accounts/{accountId}/subscriptions/projects/{projectId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the information of an existing user.
         * @summary Update Account Information
         * @param {number} accountId The numeric ID of an account
         * @param {AccountPartial} accountPartial Patch user properties to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountById: async (accountId: number, accountPartial: AccountPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccountById', 'accountId', accountId)
            // verify required parameter 'accountPartial' is not null or undefined
            assertParamExists('updateAccountById', 'accountPartial', accountPartial)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {ListProjects200Response} listProjects200Response 
         * @param {number} [projectOwner] Account ID of the owner of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewProject(listProjects200Response: ListProjects200Response, projectOwner?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewProject(listProjects200Response, projectOwner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addNewProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new account.
         * @summary Create New Account
         * @param {Account} account Post the necessary fields for the API to create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(account: Account, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(account, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create External Account
         * @param {CreateExternalAccountRequest} createExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalAccount(createExternalAccountRequest: CreateExternalAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExternalAccountRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalAccount(createExternalAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createExternalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
         * @summary Find Account by External Account Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAccountByProviderAndReferenceId(providerType, referenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findAccountByProviderAndReferenceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
         * @summary Find External Account by Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findExternalAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExternalAccountRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findExternalAccountByProviderAndReferenceId(providerType, referenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findExternalAccountByProviderAndReferenceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the information of the account with the matching account ID.
         * @summary Get Account Info by numeric ID
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountById(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountById(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all subscriptions for an account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSubscriptionsForAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllSubscriptionsForAccount200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSubscriptionsForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllSubscriptionsForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all subscriptions for a project
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSubscriptionsForProject(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllSubscriptionsForProject200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSubscriptionsForProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllSubscriptionsForProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
         * @summary Get global subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalSubscriptions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGlobalSubscriptions200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalSubscriptions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGlobalSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Show linked external accounts
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedExternalAccounts(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLinkedExternalAccounts200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedExternalAccounts(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLinkedExternalAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all projects that this account is an owner of.
         * @summary Get projects owned by this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectsForAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetProjectsForAccount200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectsForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Links an existing external account to this account (if possible)
         * @summary Link existing external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkExternalAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkExternalAccount(accountId, externalAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.linkExternalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add explicit subscription for this account and this project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeAccountToProject(accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscribeAccountToProjectRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeAccountToProject(accountId, projectId, subscribeAccountToProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.subscribeAccountToProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlink the external account from this account
         * @summary Unlink external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkExternalAccount(accountId, externalAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unlinkExternalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove explicit subscription for this account and project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeAccountFromProject(accountId: number, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeAccountFromProject(accountId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsubscribeAccountFromProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the information of an existing user.
         * @summary Update Account Information
         * @param {number} accountId The numeric ID of an account
         * @param {AccountPartial} accountPartial Patch user properties to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountById(accountId: number, accountPartial: AccountPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountById(accountId, accountPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {ListProjects200Response} listProjects200Response 
         * @param {number} [projectOwner] Account ID of the owner of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewProject(listProjects200Response: ListProjects200Response, projectOwner?: number, options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.addNewProject(listProjects200Response, projectOwner, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new account.
         * @summary Create New Account
         * @param {Account} account Post the necessary fields for the API to create a new user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(account: Account, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(account, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create External Account
         * @param {CreateExternalAccountRequest} createExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalAccount(createExternalAccountRequest: CreateExternalAccountRequest, options?: any): AxiosPromise<CreateExternalAccountRequest> {
            return localVarFp.createExternalAccount(createExternalAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
         * @summary Find Account by External Account Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: any): AxiosPromise<Account> {
            return localVarFp.findAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
         * @summary Find External Account by Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExternalAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: any): AxiosPromise<CreateExternalAccountRequest> {
            return localVarFp.findExternalAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of the account with the matching account ID.
         * @summary Get Account Info by numeric ID
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById(accountId: number, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccountById(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all subscriptions for an account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForAccount(accountId: number, options?: any): AxiosPromise<Array<GetAllSubscriptionsForAccount200ResponseInner>> {
            return localVarFp.getAllSubscriptionsForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all subscriptions for a project
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForProject(projectId: number, options?: any): AxiosPromise<Array<GetAllSubscriptionsForProject200ResponseInner>> {
            return localVarFp.getAllSubscriptionsForProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
         * @summary Get global subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSubscriptions(options?: any): AxiosPromise<Array<GetGlobalSubscriptions200ResponseInner>> {
            return localVarFp.getGlobalSubscriptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Show linked external accounts
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedExternalAccounts(accountId: number, options?: any): AxiosPromise<Array<GetLinkedExternalAccounts200ResponseInner>> {
            return localVarFp.getLinkedExternalAccounts(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: number, options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all projects that this account is an owner of.
         * @summary Get projects owned by this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForAccount(accountId: number, options?: any): AxiosPromise<Array<GetProjectsForAccount200ResponseInner>> {
            return localVarFp.getProjectsForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Links an existing external account to this account (if possible)
         * @summary Link existing external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkExternalAccount(accountId: number, externalAccountId: number, options?: any): AxiosPromise<LinkExternalAccount200Response> {
            return localVarFp.linkExternalAccount(accountId, externalAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add explicit subscription for this account and this project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeAccountToProject(accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options?: any): AxiosPromise<SubscribeAccountToProjectRequest> {
            return localVarFp.subscribeAccountToProject(accountId, projectId, subscribeAccountToProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlink the external account from this account
         * @summary Unlink external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkExternalAccount(accountId: number, externalAccountId: number, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkExternalAccount(accountId, externalAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove explicit subscription for this account and project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeAccountFromProject(accountId: number, projectId: number, options?: any): AxiosPromise<void> {
            return localVarFp.unsubscribeAccountFromProject(accountId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the information of an existing user.
         * @summary Update Account Information
         * @param {number} accountId The numeric ID of an account
         * @param {AccountPartial} accountPartial Patch user properties to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountById(accountId: number, accountPartial: AccountPartial, options?: any): AxiosPromise<Account> {
            return localVarFp.updateAccountById(accountId, accountPartial, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Add new project
     * @param {ListProjects200Response} listProjects200Response 
     * @param {number} [projectOwner] Account ID of the owner of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addNewProject(listProjects200Response: ListProjects200Response, projectOwner?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addNewProject(listProjects200Response, projectOwner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new account.
     * @summary Create New Account
     * @param {Account} account Post the necessary fields for the API to create a new user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAccount(account: Account, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAccount(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create External Account
     * @param {CreateExternalAccountRequest} createExternalAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createExternalAccount(createExternalAccountRequest: CreateExternalAccountRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createExternalAccount(createExternalAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
     * @summary Find Account by External Account Provider
     * @param {string} providerType The provider or integration type for an external account
     * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
     * @summary Find External Account by Provider
     * @param {string} providerType The provider or integration type for an external account
     * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findExternalAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findExternalAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of the account with the matching account ID.
     * @summary Get Account Info by numeric ID
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccountById(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccountById(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all subscriptions for an account
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllSubscriptionsForAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllSubscriptionsForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all subscriptions for a project
     * @param {number} projectId The numeric ID of a Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllSubscriptionsForProject(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllSubscriptionsForProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
     * @summary Get global subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGlobalSubscriptions(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGlobalSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Show linked external accounts
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLinkedExternalAccounts(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLinkedExternalAccounts(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific project by project ID
     * @param {number} projectId The numeric ID of a Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProject(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all projects that this account is an owner of.
     * @summary Get projects owned by this account
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectsForAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectsForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Links an existing external account to this account (if possible)
     * @summary Link existing external account
     * @param {number} accountId The numeric ID of an account
     * @param {number} externalAccountId The numeric ID of an external account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public linkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).linkExternalAccount(accountId, externalAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add explicit subscription for this account and this project
     * @param {number} accountId The numeric ID of an account
     * @param {number} projectId The numeric ID of a Project
     * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subscribeAccountToProject(accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscribeAccountToProject(accountId, projectId, subscribeAccountToProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlink the external account from this account
     * @summary Unlink external account
     * @param {number} accountId The numeric ID of an account
     * @param {number} externalAccountId The numeric ID of an external account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unlinkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unlinkExternalAccount(accountId, externalAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove explicit subscription for this account and project
     * @param {number} accountId The numeric ID of an account
     * @param {number} projectId The numeric ID of a Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unsubscribeAccountFromProject(accountId: number, projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsubscribeAccountFromProject(accountId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the information of an existing user.
     * @summary Update Account Information
     * @param {number} accountId The numeric ID of an account
     * @param {AccountPartial} accountPartial Patch user properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAccountById(accountId: number, accountPartial: AccountPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAccountById(accountId, accountPartial, options).then((request) => request(this.axios, this.basePath));
    }
}



