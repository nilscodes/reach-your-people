/* tslint:disable */
/* eslint-disable */
/**
 * Core Subscription Service
 * The API for the core subscription management service of the Cardano Blockchain announcement and notification application \"Reach Your People\"
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@vibrantnet.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * An ID identifying a single RYP account
     * @type {any}
     * @memberof Account
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Account
     */
    'createTime': any;
    /**
     * 
     * @type {any}
     * @memberof Account
     */
    'premiumUntil'?: any;
    /**
     * 
     * @type {any}
     * @memberof Account
     */
    'cardanoSettings'?: any;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface Account1
 */
export interface Account1 {
    /**
     * An ID identifying a single RYP account
     * @type {any}
     * @memberof Account1
     */
    'id': any;
    /**
     * 
     * @type {any}
     * @memberof Account1
     */
    'createTime': any;
    /**
     * 
     * @type {any}
     * @memberof Account1
     */
    'premiumUntil'?: any;
    /**
     * 
     * @type {any}
     * @memberof Account1
     */
    'cardanoSettings'?: any;
    /**
     * 
     * @type {string}
     * @memberof Account1
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface AccountCreate
 */
export interface AccountCreate {
    /**
     * 
     * @type {string}
     * @memberof AccountCreate
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface AccountPartial
 */
export interface AccountPartial {
    /**
     * 
     * @type {string}
     * @memberof AccountPartial
     */
    'displayName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountPartial
     */
    'cardanoSettings'?: Array<AccountPartialCardanoSettingsEnum>;
}

export const AccountPartialCardanoSettingsEnum = {
    GovernanceActionAnnouncements: 'GOVERNANCE_ACTION_ANNOUNCEMENTS'
} as const;

export type AccountPartialCardanoSettingsEnum = typeof AccountPartialCardanoSettingsEnum[keyof typeof AccountPartialCardanoSettingsEnum];

/**
 * 
 * @export
 * @interface CreateExternalAccountRequest
 */
export interface CreateExternalAccountRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateExternalAccountRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'registrationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'referenceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'referenceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'unsubscribeTime'?: string;
    /**
     * Any additional metadata for the external account (like a Push API subscription JSON blob), binary data encoded as base64.
     * @type {string}
     * @memberof CreateExternalAccountRequest
     */
    'metadata'?: string;
}
/**
 * An explicit subscription to a single project and an associated status
 * @export
 * @interface GetAllSubscriptionsForAccount200ResponseInner
 */
export interface GetAllSubscriptionsForAccount200ResponseInner {
    /**
     * A project ID or empty, if explicitly subscribed to everything
     * @type {number}
     * @memberof GetAllSubscriptionsForAccount200ResponseInner
     */
    'projectId': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllSubscriptionsForAccount200ResponseInner
     */
    'defaultStatus'?: GetAllSubscriptionsForAccount200ResponseInnerDefaultStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAllSubscriptionsForAccount200ResponseInner
     */
    'currentStatus': GetAllSubscriptionsForAccount200ResponseInnerCurrentStatusEnum;
}

export const GetAllSubscriptionsForAccount200ResponseInnerDefaultStatusEnum = {
    Subscribed: 'Subscribed',
    Unsubscribed: 'Unsubscribed'
} as const;

export type GetAllSubscriptionsForAccount200ResponseInnerDefaultStatusEnum = typeof GetAllSubscriptionsForAccount200ResponseInnerDefaultStatusEnum[keyof typeof GetAllSubscriptionsForAccount200ResponseInnerDefaultStatusEnum];
export const GetAllSubscriptionsForAccount200ResponseInnerCurrentStatusEnum = {
    Default: 'Default',
    Subscribed: 'Subscribed',
    Unsubscribed: 'Unsubscribed',
    Muted: 'Muted'
} as const;

export type GetAllSubscriptionsForAccount200ResponseInnerCurrentStatusEnum = typeof GetAllSubscriptionsForAccount200ResponseInnerCurrentStatusEnum[keyof typeof GetAllSubscriptionsForAccount200ResponseInnerCurrentStatusEnum];

/**
 * An explicit subscription to a single project and an associated status
 * @export
 * @interface GetAllSubscriptionsForProject200ResponseInner
 */
export interface GetAllSubscriptionsForProject200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetAllSubscriptionsForProject200ResponseInner
     */
    'projectId': number;
    /**
     * 
     * @type {string}
     * @memberof GetAllSubscriptionsForProject200ResponseInner
     */
    'defaultStatus'?: GetAllSubscriptionsForProject200ResponseInnerDefaultStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GetAllSubscriptionsForProject200ResponseInner
     */
    'currentStatus': GetAllSubscriptionsForProject200ResponseInnerCurrentStatusEnum;
}

export const GetAllSubscriptionsForProject200ResponseInnerDefaultStatusEnum = {
    Subscribed: 'Subscribed',
    Unsubscribed: 'Unsubscribed'
} as const;

export type GetAllSubscriptionsForProject200ResponseInnerDefaultStatusEnum = typeof GetAllSubscriptionsForProject200ResponseInnerDefaultStatusEnum[keyof typeof GetAllSubscriptionsForProject200ResponseInnerDefaultStatusEnum];
export const GetAllSubscriptionsForProject200ResponseInnerCurrentStatusEnum = {
    Default: 'Default',
    Subscribed: 'Subscribed',
    Unsubscribed: 'Unsubscribed',
    Muted: 'Muted'
} as const;

export type GetAllSubscriptionsForProject200ResponseInnerCurrentStatusEnum = typeof GetAllSubscriptionsForProject200ResponseInnerCurrentStatusEnum[keyof typeof GetAllSubscriptionsForProject200ResponseInnerCurrentStatusEnum];

/**
 * 
 * @export
 * @interface GetGlobalSubscriptions200ResponseInner
 */
export interface GetGlobalSubscriptions200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'id'?: number;
    /**
     * A project ID or empty, if explicitly subscribed to everything
     * @type {number}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'status': GetGlobalSubscriptions200ResponseInnerStatusEnum;
    /**
     * Referenced Account ID that owns this subscription setting
     * @type {number}
     * @memberof GetGlobalSubscriptions200ResponseInner
     */
    'accountId': number;
}

export const GetGlobalSubscriptions200ResponseInnerStatusEnum = {
    Default: 'Default',
    Subscribed: 'Subscribed',
    Unsubscribed: 'Unsubscribed',
    Muted: 'Muted'
} as const;

export type GetGlobalSubscriptions200ResponseInnerStatusEnum = typeof GetGlobalSubscriptions200ResponseInnerStatusEnum[keyof typeof GetGlobalSubscriptions200ResponseInnerStatusEnum];

/**
 * 
 * @export
 * @interface GetLinkedExternalAccounts200ResponseInner
 */
export interface GetLinkedExternalAccounts200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'id': number;
    /**
     * 
     * @type {CreateExternalAccountRequest}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'externalAccount': CreateExternalAccountRequest;
    /**
     * 
     * @type {string}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'role': GetLinkedExternalAccounts200ResponseInnerRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'linkTime': string;
    /**
     * 
     * @type {string}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'lastConfirmed'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'lastTested'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetLinkedExternalAccounts200ResponseInner
     */
    'settings'?: Array<GetLinkedExternalAccounts200ResponseInnerSettingsEnum>;
}

export const GetLinkedExternalAccounts200ResponseInnerRoleEnum = {
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Publisher: 'PUBLISHER',
    Subscriber: 'SUBSCRIBER'
} as const;

export type GetLinkedExternalAccounts200ResponseInnerRoleEnum = typeof GetLinkedExternalAccounts200ResponseInnerRoleEnum[keyof typeof GetLinkedExternalAccounts200ResponseInnerRoleEnum];
export const GetLinkedExternalAccounts200ResponseInnerSettingsEnum = {
    NonFungibleTokenAnnouncements: 'NON_FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    FungibleTokenAnnouncements: 'FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    RichFungibleTokenAnnouncements: 'RICH_FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    StakepoolAnnouncements: 'STAKEPOOL_ANNOUNCEMENTS',
    DrepAnnouncements: 'DREP_ANNOUNCEMENTS',
    DefaultForNotifications: 'DEFAULT_FOR_NOTIFICATIONS'
} as const;

export type GetLinkedExternalAccounts200ResponseInnerSettingsEnum = typeof GetLinkedExternalAccounts200ResponseInnerSettingsEnum[keyof typeof GetLinkedExternalAccounts200ResponseInnerSettingsEnum];

/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInner
 */
export interface GetProjectsForAccount200ResponseInner {
    /**
     * 
     * @type {number}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'category'?: GetProjectsForAccount200ResponseInnerCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'registrationTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'verified'?: boolean;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerDrepsInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'dreps'?: Array<GetProjectsForAccount200ResponseInnerDrepsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'stakepools'?: Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerPoliciesInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'policies'?: Array<GetProjectsForAccount200ResponseInnerPoliciesInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerSocialsInner>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'socials'?: Array<GetProjectsForAccount200ResponseInnerSocialsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'wallets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInner
     */
    'manuallyVerified'?: string;
}

export const GetProjectsForAccount200ResponseInnerCategoryEnum = {
    DeFi: 'DeFi',
    Nft: 'NFT',
    Spo: 'SPO',
    DRep: 'dRep',
    Dao: 'DAO',
    Other: 'Other'
} as const;

export type GetProjectsForAccount200ResponseInnerCategoryEnum = typeof GetProjectsForAccount200ResponseInnerCategoryEnum[keyof typeof GetProjectsForAccount200ResponseInnerCategoryEnum];

/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerDrepsInner
 */
export interface GetProjectsForAccount200ResponseInnerDrepsInner {
    /**
     * The dRep pubkey blake hash in hex
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerDrepsInner
     */
    'drepId': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerDrepsInner
     */
    'verificationNonce': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerDrepsInner
     */
    'verificationTime'?: string;
}
/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerPoliciesInner
 */
export interface GetProjectsForAccount200ResponseInnerPoliciesInner {
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerPoliciesInner
     */
    'name'?: string;
    /**
     * The Policy ID
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerPoliciesInner
     */
    'policyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerPoliciesInner
     */
    'manuallyVerified'?: string;
}
/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerSocialsInner
 */
export interface GetProjectsForAccount200ResponseInnerSocialsInner {
    /**
     * 
     * @type {number}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'referenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'referenceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerSocialsInner
     */
    'type'?: GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum;
}

export const GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum = {
    Twitter: 'TWITTER',
    Discord: 'DISCORD'
} as const;

export type GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum = typeof GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum[keyof typeof GetProjectsForAccount200ResponseInnerSocialsInnerTypeEnum];

/**
 * 
 * @export
 * @interface GetProjectsForAccount200ResponseInnerStakepoolsInner
 */
export interface GetProjectsForAccount200ResponseInnerStakepoolsInner {
    /**
     * The stakepool hash in hex
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'poolHash': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'verificationNonce': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectsForAccount200ResponseInnerStakepoolsInner
     */
    'verificationTime'?: string;
}
/**
 * 
 * @export
 * @interface LinkExternalAccount200Response
 */
export interface LinkExternalAccount200Response {
    /**
     * 
     * @type {number}
     * @memberof LinkExternalAccount200Response
     */
    'id': number;
    /**
     * 
     * @type {CreateExternalAccountRequest}
     * @memberof LinkExternalAccount200Response
     */
    'externalAccount': CreateExternalAccountRequest;
    /**
     * 
     * @type {string}
     * @memberof LinkExternalAccount200Response
     */
    'role': LinkExternalAccount200ResponseRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof LinkExternalAccount200Response
     */
    'linkTime': string;
    /**
     * 
     * @type {string}
     * @memberof LinkExternalAccount200Response
     */
    'lastConfirmed'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkExternalAccount200Response
     */
    'lastTested'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LinkExternalAccount200Response
     */
    'settings'?: Array<LinkExternalAccount200ResponseSettingsEnum>;
}

export const LinkExternalAccount200ResponseRoleEnum = {
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Publisher: 'PUBLISHER',
    Subscriber: 'SUBSCRIBER'
} as const;

export type LinkExternalAccount200ResponseRoleEnum = typeof LinkExternalAccount200ResponseRoleEnum[keyof typeof LinkExternalAccount200ResponseRoleEnum];
export const LinkExternalAccount200ResponseSettingsEnum = {
    NonFungibleTokenAnnouncements: 'NON_FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    FungibleTokenAnnouncements: 'FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    RichFungibleTokenAnnouncements: 'RICH_FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    StakepoolAnnouncements: 'STAKEPOOL_ANNOUNCEMENTS',
    DrepAnnouncements: 'DREP_ANNOUNCEMENTS',
    DefaultForNotifications: 'DEFAULT_FOR_NOTIFICATIONS'
} as const;

export type LinkExternalAccount200ResponseSettingsEnum = typeof LinkExternalAccount200ResponseSettingsEnum[keyof typeof LinkExternalAccount200ResponseSettingsEnum];

/**
 * 
 * @export
 * @interface ListProjects200Response
 */
export interface ListProjects200Response {
    /**
     * 
     * @type {number}
     * @memberof ListProjects200Response
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'category'?: ListProjects200ResponseCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListProjects200Response
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'registrationTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListProjects200Response
     */
    'verified'?: boolean;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerDrepsInner>}
     * @memberof ListProjects200Response
     */
    'dreps'?: Array<GetProjectsForAccount200ResponseInnerDrepsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>}
     * @memberof ListProjects200Response
     */
    'stakepools'?: Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerPoliciesInner>}
     * @memberof ListProjects200Response
     */
    'policies'?: Array<GetProjectsForAccount200ResponseInnerPoliciesInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerSocialsInner>}
     * @memberof ListProjects200Response
     */
    'socials'?: Array<GetProjectsForAccount200ResponseInnerSocialsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListProjects200Response
     */
    'wallets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListProjects200Response
     */
    'manuallyVerified'?: string;
}

export const ListProjects200ResponseCategoryEnum = {
    DeFi: 'DeFi',
    Nft: 'NFT',
    Spo: 'SPO',
    DRep: 'dRep',
    Dao: 'DAO',
    Other: 'Other'
} as const;

export type ListProjects200ResponseCategoryEnum = typeof ListProjects200ResponseCategoryEnum[keyof typeof ListProjects200ResponseCategoryEnum];

/**
 * 
 * @export
 * @interface ProjectNotificationSetting
 */
export interface ProjectNotificationSetting {
    /**
     * 
     * @type {number}
     * @memberof ProjectNotificationSetting
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectNotificationSetting
     */
    'projectId': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectNotificationSetting
     */
    'externalAccountLinkId': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectNotificationSetting
     */
    'createTime'?: string;
}
/**
 * 
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SubscribeAccountToProjectRequest
 */
export interface SubscribeAccountToProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof SubscribeAccountToProjectRequest
     */
    'status': SubscribeAccountToProjectRequestStatusEnum;
}

export const SubscribeAccountToProjectRequestStatusEnum = {
    Default: 'Default',
    Subscribed: 'Subscribed',
    Unsubscribed: 'Unsubscribed',
    Muted: 'Muted'
} as const;

export type SubscribeAccountToProjectRequestStatusEnum = typeof SubscribeAccountToProjectRequestStatusEnum[keyof typeof SubscribeAccountToProjectRequestStatusEnum];

/**
 * 
 * @export
 * @interface UnsubscribeFromEmailRequest
 */
export interface UnsubscribeFromEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof UnsubscribeFromEmailRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UpdateLinkedExternalAccountRequest
 */
export interface UpdateLinkedExternalAccountRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateLinkedExternalAccountRequest
     */
    'settings'?: Array<UpdateLinkedExternalAccountRequestSettingsEnum>;
    /**
     * 
     * @type {string}
     * @memberof UpdateLinkedExternalAccountRequest
     */
    'lastConfirmed'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLinkedExternalAccountRequest
     */
    'lastTested'?: string;
}

export const UpdateLinkedExternalAccountRequestSettingsEnum = {
    NonFungibleTokenAnnouncements: 'NON_FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    FungibleTokenAnnouncements: 'FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    RichFungibleTokenAnnouncements: 'RICH_FUNGIBLE_TOKEN_ANNOUNCEMENTS',
    StakepoolAnnouncements: 'STAKEPOOL_ANNOUNCEMENTS',
    DrepAnnouncements: 'DREP_ANNOUNCEMENTS',
    DefaultForNotifications: 'DEFAULT_FOR_NOTIFICATIONS'
} as const;

export type UpdateLinkedExternalAccountRequestSettingsEnum = typeof UpdateLinkedExternalAccountRequestSettingsEnum[keyof typeof UpdateLinkedExternalAccountRequestSettingsEnum];

/**
 * 
 * @export
 * @interface UpdateProjectRequest
 */
export interface UpdateProjectRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'category'?: UpdateProjectRequestCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProjectRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerDrepsInner>}
     * @memberof UpdateProjectRequest
     */
    'dreps'?: Array<GetProjectsForAccount200ResponseInnerDrepsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>}
     * @memberof UpdateProjectRequest
     */
    'stakepools'?: Array<GetProjectsForAccount200ResponseInnerStakepoolsInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerPoliciesInner>}
     * @memberof UpdateProjectRequest
     */
    'policies'?: Array<GetProjectsForAccount200ResponseInnerPoliciesInner>;
    /**
     * 
     * @type {Array<GetProjectsForAccount200ResponseInnerSocialsInner>}
     * @memberof UpdateProjectRequest
     */
    'socials'?: Array<GetProjectsForAccount200ResponseInnerSocialsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProjectRequest
     */
    'wallets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectRequest
     */
    'manuallyVerified'?: string;
}

export const UpdateProjectRequestCategoryEnum = {
    DeFi: 'DeFi',
    Nft: 'NFT',
    Spo: 'SPO',
    DRep: 'dRep',
    Dao: 'DAO',
    Other: 'Other'
} as const;

export type UpdateProjectRequestCategoryEnum = typeof UpdateProjectRequestCategoryEnum[keyof typeof UpdateProjectRequestCategoryEnum];


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add new project
         * @param {ListProjects200Response} listProjects200Response 
         * @param {number} [projectOwner] Account ID of the owner of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewProject: async (listProjects200Response: ListProjects200Response, projectOwner?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listProjects200Response' is not null or undefined
            assertParamExists('addNewProject', 'listProjects200Response', listProjects200Response)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectOwner !== undefined) {
                localVarQueryParameter['projectOwner'] = projectOwner;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listProjects200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new account.
         * @summary Create New Account
         * @param {AccountCreate} accountCreate Post the necessary fields for the API to create a new user.
         * @param {number} [referredBy] Account ID of the user that referred this new account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (accountCreate: AccountCreate, referredBy?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountCreate' is not null or undefined
            assertParamExists('createAccount', 'accountCreate', accountCreate)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (referredBy !== undefined) {
                localVarQueryParameter['referredBy'] = referredBy;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create External Account
         * @param {CreateExternalAccountRequest} createExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalAccount: async (createExternalAccountRequest: CreateExternalAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createExternalAccountRequest' is not null or undefined
            assertParamExists('createExternalAccount', 'createExternalAccountRequest', createExternalAccountRequest)
            const localVarPath = `/externalaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExternalAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a single account setting
         * @summary Delete account setting
         * @param {number} accountId The numeric ID of an account
         * @param {string} settingName The name of the setting to adjust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountSetting: async (accountId: number, settingName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccountSetting', 'accountId', accountId)
            // verify required parameter 'settingName' is not null or undefined
            assertParamExists('deleteAccountSetting', 'settingName', settingName)
            const localVarPath = `/accounts/{accountId}/settings/{settingName}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"settingName"}}`, encodeURIComponent(String(settingName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
         * @summary Find Account by External Account Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountByProviderAndReferenceId: async (providerType: string, referenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerType' is not null or undefined
            assertParamExists('findAccountByProviderAndReferenceId', 'providerType', providerType)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('findAccountByProviderAndReferenceId', 'referenceId', referenceId)
            const localVarPath = `/accounts/{providerType}/{referenceId}`
                .replace(`{${"providerType"}}`, encodeURIComponent(String(providerType)))
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
         * @summary Find External Account by Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExternalAccountByProviderAndReferenceId: async (providerType: string, referenceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerType' is not null or undefined
            assertParamExists('findExternalAccountByProviderAndReferenceId', 'providerType', providerType)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('findExternalAccountByProviderAndReferenceId', 'referenceId', referenceId)
            const localVarPath = `/externalaccounts/{providerType}/{referenceId}`
                .replace(`{${"providerType"}}`, encodeURIComponent(String(providerType)))
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of the account with the matching account ID.
         * @summary Get Account Info by numeric ID
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountById', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all subscriptions for an account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAllSubscriptionsForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/subscriptions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all subscriptions for a project
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForProject: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAllSubscriptionsForProject', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/subscriptions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
         * @summary Get global subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSubscriptions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions/global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Show linked external accounts
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedExternalAccounts: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getLinkedExternalAccounts', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/externalaccounts`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current notification settings for this account on this project.
         * @summary Get project notification settings
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSettingsForAccountAndProject: async (accountId: number, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getNotificationsSettingsForAccountAndProject', 'accountId', accountId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getNotificationsSettingsForAccountAndProject', 'projectId', projectId)
            const localVarPath = `/accounts/{accountId}/projects/{projectId}/notifications`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getProject', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all projects that this account is an owner of.
         * @summary Get projects owned by this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getProjectsForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/projects`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all settings that this account has configured.
         * @summary Get settings for this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsForAccount: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getSettingsForAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/settings`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links an existing external account to this account (if possible)
         * @summary Link existing external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkExternalAccount: async (accountId: number, externalAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('linkExternalAccount', 'accountId', accountId)
            // verify required parameter 'externalAccountId' is not null or undefined
            assertParamExists('linkExternalAccount', 'externalAccountId', externalAccountId)
            const localVarPath = `/accounts/{accountId}/externalaccounts/{externalAccountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"externalAccountId"}}`, encodeURIComponent(String(externalAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add explicit subscription for this account and this project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeAccountToProject: async (accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('subscribeAccountToProject', 'accountId', accountId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('subscribeAccountToProject', 'projectId', projectId)
            // verify required parameter 'subscribeAccountToProjectRequest' is not null or undefined
            assertParamExists('subscribeAccountToProject', 'subscribeAccountToProjectRequest', subscribeAccountToProjectRequest)
            const localVarPath = `/accounts/{accountId}/subscriptions/projects/{projectId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeAccountToProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlink the external account from this account
         * @summary Unlink external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkExternalAccount: async (accountId: number, externalAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('unlinkExternalAccount', 'accountId', accountId)
            // verify required parameter 'externalAccountId' is not null or undefined
            assertParamExists('unlinkExternalAccount', 'externalAccountId', externalAccountId)
            const localVarPath = `/accounts/{accountId}/externalaccounts/{externalAccountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"externalAccountId"}}`, encodeURIComponent(String(externalAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove explicit subscription for this account and project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeAccountFromProject: async (accountId: number, projectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('unsubscribeAccountFromProject', 'accountId', accountId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unsubscribeAccountFromProject', 'projectId', projectId)
            const localVarPath = `/accounts/{accountId}/subscriptions/projects/{projectId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To comply with spam protection laws, we allow an email to unsubscribe even if the person is not logged in or can confirm ownership of the email address.
         * @summary Unsubscribe any email address from the service
         * @param {UnsubscribeFromEmailRequest} [unsubscribeFromEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeFromEmail: async (unsubscribeFromEmailRequest?: UnsubscribeFromEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/email/unsubscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unsubscribeFromEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the information of an existing user.
         * @summary Update Account Information
         * @param {number} accountId The numeric ID of an account
         * @param {AccountPartial} accountPartial Patch user properties to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountById: async (accountId: number, accountPartial: AccountPartial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccountById', 'accountId', accountId)
            // verify required parameter 'accountPartial' is not null or undefined
            assertParamExists('updateAccountById', 'accountPartial', accountPartial)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPartial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a single account setting with the provided value
         * @summary Update account setting
         * @param {number} accountId The numeric ID of an account
         * @param {string} settingName The name of the setting to adjust
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSetting: async (accountId: number, settingName: string, setting: Setting, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccountSetting', 'accountId', accountId)
            // verify required parameter 'settingName' is not null or undefined
            assertParamExists('updateAccountSetting', 'settingName', settingName)
            // verify required parameter 'setting' is not null or undefined
            assertParamExists('updateAccountSetting', 'setting', setting)
            const localVarPath = `/accounts/{accountId}/settings/{settingName}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"settingName"}}`, encodeURIComponent(String(settingName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing linked external account and changes its settings
         * @summary Update settings for a linked external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {UpdateLinkedExternalAccountRequest} updateLinkedExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkedExternalAccount: async (accountId: number, externalAccountId: number, updateLinkedExternalAccountRequest: UpdateLinkedExternalAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateLinkedExternalAccount', 'accountId', accountId)
            // verify required parameter 'externalAccountId' is not null or undefined
            assertParamExists('updateLinkedExternalAccount', 'externalAccountId', externalAccountId)
            // verify required parameter 'updateLinkedExternalAccountRequest' is not null or undefined
            assertParamExists('updateLinkedExternalAccount', 'updateLinkedExternalAccountRequest', updateLinkedExternalAccountRequest)
            const localVarPath = `/accounts/{accountId}/externalaccounts/{externalAccountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"externalAccountId"}}`, encodeURIComponent(String(externalAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLinkedExternalAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * In particular for emails and phone numbers it is possible to unsubscribe to comply with spam protection laws. This endpoint allows users to resubscribe. It verifies that the account has been verified recently (configurable) and if yes, re-enables the subscription.
         * @summary Resubscribe an explicitly unsubscribed external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkedExternalAccountSubscriptionStatus: async (accountId: number, externalAccountId: number, body: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateLinkedExternalAccountSubscriptionStatus', 'accountId', accountId)
            // verify required parameter 'externalAccountId' is not null or undefined
            assertParamExists('updateLinkedExternalAccountSubscriptionStatus', 'externalAccountId', externalAccountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateLinkedExternalAccountSubscriptionStatus', 'body', body)
            const localVarPath = `/accounts/{accountId}/externalaccounts/{externalAccountId}/subscriptionstatus`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"externalAccountId"}}`, encodeURIComponent(String(externalAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the notification settings for this account on this project. Will remove any invalid settings, like notification settings for non-linked external accounts or external accounts that cannot receive notifications.
         * @summary Update the notification settings
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {Array<ProjectNotificationSetting>} projectNotificationSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationsSettingsForAccountAndProject: async (accountId: number, projectId: number, projectNotificationSetting: Array<ProjectNotificationSetting>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateNotificationsSettingsForAccountAndProject', 'accountId', accountId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateNotificationsSettingsForAccountAndProject', 'projectId', projectId)
            // verify required parameter 'projectNotificationSetting' is not null or undefined
            assertParamExists('updateNotificationsSettingsForAccountAndProject', 'projectNotificationSetting', projectNotificationSetting)
            const localVarPath = `/accounts/{accountId}/projects/{projectId}/notifications`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectNotificationSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {UpdateProjectRequest} [updateProjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: number, updateProjectRequest?: UpdateProjectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {ListProjects200Response} listProjects200Response 
         * @param {number} [projectOwner] Account ID of the owner of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewProject(listProjects200Response: ListProjects200Response, projectOwner?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNewProject(listProjects200Response, projectOwner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addNewProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new account.
         * @summary Create New Account
         * @param {AccountCreate} accountCreate Post the necessary fields for the API to create a new user.
         * @param {number} [referredBy] Account ID of the user that referred this new account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(accountCreate: AccountCreate, referredBy?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(accountCreate, referredBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create External Account
         * @param {CreateExternalAccountRequest} createExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalAccount(createExternalAccountRequest: CreateExternalAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExternalAccountRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalAccount(createExternalAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createExternalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a single account setting
         * @summary Delete account setting
         * @param {number} accountId The numeric ID of an account
         * @param {string} settingName The name of the setting to adjust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountSetting(accountId: number, settingName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountSetting(accountId, settingName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteAccountSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
         * @summary Find Account by External Account Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAccountByProviderAndReferenceId(providerType, referenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findAccountByProviderAndReferenceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
         * @summary Find External Account by Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findExternalAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExternalAccountRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findExternalAccountByProviderAndReferenceId(providerType, referenceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findExternalAccountByProviderAndReferenceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the information of the account with the matching account ID.
         * @summary Get Account Info by numeric ID
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountById(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountById(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all subscriptions for an account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSubscriptionsForAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllSubscriptionsForAccount200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSubscriptionsForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllSubscriptionsForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all subscriptions for a project
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSubscriptionsForProject(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAllSubscriptionsForProject200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSubscriptionsForProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getAllSubscriptionsForProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
         * @summary Get global subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalSubscriptions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGlobalSubscriptions200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalSubscriptions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getGlobalSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Show linked external accounts
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkedExternalAccounts(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLinkedExternalAccounts200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkedExternalAccounts(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLinkedExternalAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current notification settings for this account on this project.
         * @summary Get project notification settings
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsSettingsForAccountAndProject(accountId: number, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectNotificationSetting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationsSettingsForAccountAndProject(accountId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getNotificationsSettingsForAccountAndProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all projects that this account is an owner of.
         * @summary Get projects owned by this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjectsForAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetProjectsForAccount200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjectsForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getProjectsForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all settings that this account has configured.
         * @summary Get settings for this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingsForAccount(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingsForAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSettingsForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Links an existing external account to this account (if possible)
         * @summary Link existing external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkExternalAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkExternalAccount(accountId, externalAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.linkExternalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add explicit subscription for this account and this project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeAccountToProject(accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscribeAccountToProjectRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeAccountToProject(accountId, projectId, subscribeAccountToProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.subscribeAccountToProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlink the external account from this account
         * @summary Unlink external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkExternalAccount(accountId, externalAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unlinkExternalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove explicit subscription for this account and project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeAccountFromProject(accountId: number, projectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeAccountFromProject(accountId, projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsubscribeAccountFromProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To comply with spam protection laws, we allow an email to unsubscribe even if the person is not logged in or can confirm ownership of the email address.
         * @summary Unsubscribe any email address from the service
         * @param {UnsubscribeFromEmailRequest} [unsubscribeFromEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeFromEmail(unsubscribeFromEmailRequest?: UnsubscribeFromEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeFromEmail(unsubscribeFromEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.unsubscribeFromEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the information of an existing user.
         * @summary Update Account Information
         * @param {number} accountId The numeric ID of an account
         * @param {AccountPartial} accountPartial Patch user properties to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountById(accountId: number, accountPartial: AccountPartial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountById(accountId, accountPartial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateAccountById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update a single account setting with the provided value
         * @summary Update account setting
         * @param {number} accountId The numeric ID of an account
         * @param {string} settingName The name of the setting to adjust
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountSetting(accountId: number, settingName: string, setting: Setting, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountSetting(accountId, settingName, setting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateAccountSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing linked external account and changes its settings
         * @summary Update settings for a linked external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {UpdateLinkedExternalAccountRequest} updateLinkedExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLinkedExternalAccount(accountId: number, externalAccountId: number, updateLinkedExternalAccountRequest: UpdateLinkedExternalAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkExternalAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLinkedExternalAccount(accountId, externalAccountId, updateLinkedExternalAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLinkedExternalAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * In particular for emails and phone numbers it is possible to unsubscribe to comply with spam protection laws. This endpoint allows users to resubscribe. It verifies that the account has been verified recently (configurable) and if yes, re-enables the subscription.
         * @summary Resubscribe an explicitly unsubscribed external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLinkedExternalAccountSubscriptionStatus(accountId: number, externalAccountId: number, body: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLinkedExternalAccountSubscriptionStatus(accountId, externalAccountId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLinkedExternalAccountSubscriptionStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the notification settings for this account on this project. Will remove any invalid settings, like notification settings for non-linked external accounts or external accounts that cannot receive notifications.
         * @summary Update the notification settings
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {Array<ProjectNotificationSetting>} projectNotificationSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationsSettingsForAccountAndProject(accountId: number, projectId: number, projectNotificationSetting: Array<ProjectNotificationSetting>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectNotificationSetting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationsSettingsForAccountAndProject(accountId, projectId, projectNotificationSetting, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateNotificationsSettingsForAccountAndProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {UpdateProjectRequest} [updateProjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: number, updateProjectRequest?: UpdateProjectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListProjects200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, updateProjectRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Add new project
         * @param {ListProjects200Response} listProjects200Response 
         * @param {number} [projectOwner] Account ID of the owner of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewProject(listProjects200Response: ListProjects200Response, projectOwner?: number, options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.addNewProject(listProjects200Response, projectOwner, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new account.
         * @summary Create New Account
         * @param {AccountCreate} accountCreate Post the necessary fields for the API to create a new user.
         * @param {number} [referredBy] Account ID of the user that referred this new account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(accountCreate: AccountCreate, referredBy?: number, options?: any): AxiosPromise<Account> {
            return localVarFp.createAccount(accountCreate, referredBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create External Account
         * @param {CreateExternalAccountRequest} createExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalAccount(createExternalAccountRequest: CreateExternalAccountRequest, options?: any): AxiosPromise<CreateExternalAccountRequest> {
            return localVarFp.createExternalAccount(createExternalAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a single account setting
         * @summary Delete account setting
         * @param {number} accountId The numeric ID of an account
         * @param {string} settingName The name of the setting to adjust
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountSetting(accountId: number, settingName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccountSetting(accountId, settingName, options).then((request) => request(axios, basePath));
        },
        /**
         * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
         * @summary Find Account by External Account Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: any): AxiosPromise<Account1> {
            return localVarFp.findAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
         * @summary Find External Account by Provider
         * @param {string} providerType The provider or integration type for an external account
         * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExternalAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: any): AxiosPromise<CreateExternalAccountRequest> {
            return localVarFp.findExternalAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of the account with the matching account ID.
         * @summary Get Account Info by numeric ID
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountById(accountId: number, options?: any): AxiosPromise<Account1> {
            return localVarFp.getAccountById(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all subscriptions for an account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForAccount(accountId: number, options?: any): AxiosPromise<Array<GetAllSubscriptionsForAccount200ResponseInner>> {
            return localVarFp.getAllSubscriptionsForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all subscriptions for a project
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubscriptionsForProject(projectId: number, options?: any): AxiosPromise<Array<GetAllSubscriptionsForProject200ResponseInner>> {
            return localVarFp.getAllSubscriptionsForProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
         * @summary Get global subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSubscriptions(options?: any): AxiosPromise<Array<GetGlobalSubscriptions200ResponseInner>> {
            return localVarFp.getGlobalSubscriptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Show linked external accounts
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedExternalAccounts(accountId: number, options?: any): AxiosPromise<Array<GetLinkedExternalAccounts200ResponseInner>> {
            return localVarFp.getLinkedExternalAccounts(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current notification settings for this account on this project.
         * @summary Get project notification settings
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSettingsForAccountAndProject(accountId: number, projectId: number, options?: any): AxiosPromise<Array<ProjectNotificationSetting>> {
            return localVarFp.getNotificationsSettingsForAccountAndProject(accountId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectId: number, options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.getProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all projects that this account is an owner of.
         * @summary Get projects owned by this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectsForAccount(accountId: number, options?: any): AxiosPromise<Array<GetProjectsForAccount200ResponseInner>> {
            return localVarFp.getProjectsForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all settings that this account has configured.
         * @summary Get settings for this account
         * @param {number} accountId The numeric ID of an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsForAccount(accountId: number, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getSettingsForAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Links an existing external account to this account (if possible)
         * @summary Link existing external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkExternalAccount(accountId: number, externalAccountId: number, options?: any): AxiosPromise<LinkExternalAccount200Response> {
            return localVarFp.linkExternalAccount(accountId, externalAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.listProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add explicit subscription for this account and this project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeAccountToProject(accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options?: any): AxiosPromise<SubscribeAccountToProjectRequest> {
            return localVarFp.subscribeAccountToProject(accountId, projectId, subscribeAccountToProjectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlink the external account from this account
         * @summary Unlink external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkExternalAccount(accountId: number, externalAccountId: number, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkExternalAccount(accountId, externalAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove explicit subscription for this account and project
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeAccountFromProject(accountId: number, projectId: number, options?: any): AxiosPromise<void> {
            return localVarFp.unsubscribeAccountFromProject(accountId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * To comply with spam protection laws, we allow an email to unsubscribe even if the person is not logged in or can confirm ownership of the email address.
         * @summary Unsubscribe any email address from the service
         * @param {UnsubscribeFromEmailRequest} [unsubscribeFromEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeFromEmail(unsubscribeFromEmailRequest?: UnsubscribeFromEmailRequest, options?: any): AxiosPromise<void> {
            return localVarFp.unsubscribeFromEmail(unsubscribeFromEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the information of an existing user.
         * @summary Update Account Information
         * @param {number} accountId The numeric ID of an account
         * @param {AccountPartial} accountPartial Patch user properties to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountById(accountId: number, accountPartial: AccountPartial, options?: any): AxiosPromise<Account1> {
            return localVarFp.updateAccountById(accountId, accountPartial, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a single account setting with the provided value
         * @summary Update account setting
         * @param {number} accountId The numeric ID of an account
         * @param {string} settingName The name of the setting to adjust
         * @param {Setting} setting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountSetting(accountId: number, settingName: string, setting: Setting, options?: any): AxiosPromise<Setting> {
            return localVarFp.updateAccountSetting(accountId, settingName, setting, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing linked external account and changes its settings
         * @summary Update settings for a linked external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {UpdateLinkedExternalAccountRequest} updateLinkedExternalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkedExternalAccount(accountId: number, externalAccountId: number, updateLinkedExternalAccountRequest: UpdateLinkedExternalAccountRequest, options?: any): AxiosPromise<LinkExternalAccount200Response> {
            return localVarFp.updateLinkedExternalAccount(accountId, externalAccountId, updateLinkedExternalAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * In particular for emails and phone numbers it is possible to unsubscribe to comply with spam protection laws. This endpoint allows users to resubscribe. It verifies that the account has been verified recently (configurable) and if yes, re-enables the subscription.
         * @summary Resubscribe an explicitly unsubscribed external account
         * @param {number} accountId The numeric ID of an account
         * @param {number} externalAccountId The numeric ID of an external account
         * @param {boolean} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkedExternalAccountSubscriptionStatus(accountId: number, externalAccountId: number, body: boolean, options?: any): AxiosPromise<boolean> {
            return localVarFp.updateLinkedExternalAccountSubscriptionStatus(accountId, externalAccountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the notification settings for this account on this project. Will remove any invalid settings, like notification settings for non-linked external accounts or external accounts that cannot receive notifications.
         * @summary Update the notification settings
         * @param {number} accountId The numeric ID of an account
         * @param {number} projectId The numeric ID of a Project
         * @param {Array<ProjectNotificationSetting>} projectNotificationSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationsSettingsForAccountAndProject(accountId: number, projectId: number, projectNotificationSetting: Array<ProjectNotificationSetting>, options?: any): AxiosPromise<Array<ProjectNotificationSetting>> {
            return localVarFp.updateNotificationsSettingsForAccountAndProject(accountId, projectId, projectNotificationSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific project by project ID
         * @param {number} projectId The numeric ID of a Project
         * @param {UpdateProjectRequest} [updateProjectRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: number, updateProjectRequest?: UpdateProjectRequest, options?: any): AxiosPromise<ListProjects200Response> {
            return localVarFp.updateProject(projectId, updateProjectRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Add new project
     * @param {ListProjects200Response} listProjects200Response 
     * @param {number} [projectOwner] Account ID of the owner of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addNewProject(listProjects200Response: ListProjects200Response, projectOwner?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addNewProject(listProjects200Response, projectOwner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new account.
     * @summary Create New Account
     * @param {AccountCreate} accountCreate Post the necessary fields for the API to create a new user.
     * @param {number} [referredBy] Account ID of the user that referred this new account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAccount(accountCreate: AccountCreate, referredBy?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAccount(accountCreate, referredBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create External Account
     * @param {CreateExternalAccountRequest} createExternalAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createExternalAccount(createExternalAccountRequest: CreateExternalAccountRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createExternalAccount(createExternalAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a single account setting
     * @summary Delete account setting
     * @param {number} accountId The numeric ID of an account
     * @param {string} settingName The name of the setting to adjust
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAccountSetting(accountId: number, settingName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteAccountSetting(accountId, settingName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Look up an account by provider and the corresponding reference ID, to see if the account is used somewhere, without knowing the internal ID of the linked OWNER account
     * @summary Find Account by External Account Provider
     * @param {string} providerType The provider or integration type for an external account
     * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Look up an external account by provider and the corresponding reference ID, to see if the external account is used somewhere, without knowing the internal ID.
     * @summary Find External Account by Provider
     * @param {string} providerType The provider or integration type for an external account
     * @param {string} referenceId The reference ID used to identify the user in the external provider/integration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findExternalAccountByProviderAndReferenceId(providerType: string, referenceId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findExternalAccountByProviderAndReferenceId(providerType, referenceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of the account with the matching account ID.
     * @summary Get Account Info by numeric ID
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccountById(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccountById(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all subscriptions for an account
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllSubscriptionsForAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllSubscriptionsForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all subscriptions for a project
     * @param {number} projectId The numeric ID of a Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllSubscriptionsForProject(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAllSubscriptionsForProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all subscriptions that are global and as such relate to everything that occurs to projects related in an account\'s wallet.
     * @summary Get global subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getGlobalSubscriptions(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getGlobalSubscriptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Show linked external accounts
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLinkedExternalAccounts(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLinkedExternalAccounts(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current notification settings for this account on this project.
     * @summary Get project notification settings
     * @param {number} accountId The numeric ID of an account
     * @param {number} projectId The numeric ID of a Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNotificationsSettingsForAccountAndProject(accountId: number, projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNotificationsSettingsForAccountAndProject(accountId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific project by project ID
     * @param {number} projectId The numeric ID of a Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProject(projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all projects that this account is an owner of.
     * @summary Get projects owned by this account
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProjectsForAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getProjectsForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all settings that this account has configured.
     * @summary Get settings for this account
     * @param {number} accountId The numeric ID of an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSettingsForAccount(accountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSettingsForAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Links an existing external account to this account (if possible)
     * @summary Link existing external account
     * @param {number} accountId The numeric ID of an account
     * @param {number} externalAccountId The numeric ID of an external account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public linkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).linkExternalAccount(accountId, externalAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listProjects(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add explicit subscription for this account and this project
     * @param {number} accountId The numeric ID of an account
     * @param {number} projectId The numeric ID of a Project
     * @param {SubscribeAccountToProjectRequest} subscribeAccountToProjectRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public subscribeAccountToProject(accountId: number, projectId: number, subscribeAccountToProjectRequest: SubscribeAccountToProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).subscribeAccountToProject(accountId, projectId, subscribeAccountToProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlink the external account from this account
     * @summary Unlink external account
     * @param {number} accountId The numeric ID of an account
     * @param {number} externalAccountId The numeric ID of an external account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unlinkExternalAccount(accountId: number, externalAccountId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unlinkExternalAccount(accountId, externalAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove explicit subscription for this account and project
     * @param {number} accountId The numeric ID of an account
     * @param {number} projectId The numeric ID of a Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unsubscribeAccountFromProject(accountId: number, projectId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsubscribeAccountFromProject(accountId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To comply with spam protection laws, we allow an email to unsubscribe even if the person is not logged in or can confirm ownership of the email address.
     * @summary Unsubscribe any email address from the service
     * @param {UnsubscribeFromEmailRequest} [unsubscribeFromEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unsubscribeFromEmail(unsubscribeFromEmailRequest?: UnsubscribeFromEmailRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsubscribeFromEmail(unsubscribeFromEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the information of an existing user.
     * @summary Update Account Information
     * @param {number} accountId The numeric ID of an account
     * @param {AccountPartial} accountPartial Patch user properties to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAccountById(accountId: number, accountPartial: AccountPartial, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAccountById(accountId, accountPartial, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a single account setting with the provided value
     * @summary Update account setting
     * @param {number} accountId The numeric ID of an account
     * @param {string} settingName The name of the setting to adjust
     * @param {Setting} setting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAccountSetting(accountId: number, settingName: string, setting: Setting, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateAccountSetting(accountId, settingName, setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing linked external account and changes its settings
     * @summary Update settings for a linked external account
     * @param {number} accountId The numeric ID of an account
     * @param {number} externalAccountId The numeric ID of an external account
     * @param {UpdateLinkedExternalAccountRequest} updateLinkedExternalAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateLinkedExternalAccount(accountId: number, externalAccountId: number, updateLinkedExternalAccountRequest: UpdateLinkedExternalAccountRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLinkedExternalAccount(accountId, externalAccountId, updateLinkedExternalAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * In particular for emails and phone numbers it is possible to unsubscribe to comply with spam protection laws. This endpoint allows users to resubscribe. It verifies that the account has been verified recently (configurable) and if yes, re-enables the subscription.
     * @summary Resubscribe an explicitly unsubscribed external account
     * @param {number} accountId The numeric ID of an account
     * @param {number} externalAccountId The numeric ID of an external account
     * @param {boolean} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateLinkedExternalAccountSubscriptionStatus(accountId: number, externalAccountId: number, body: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLinkedExternalAccountSubscriptionStatus(accountId, externalAccountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the notification settings for this account on this project. Will remove any invalid settings, like notification settings for non-linked external accounts or external accounts that cannot receive notifications.
     * @summary Update the notification settings
     * @param {number} accountId The numeric ID of an account
     * @param {number} projectId The numeric ID of a Project
     * @param {Array<ProjectNotificationSetting>} projectNotificationSetting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateNotificationsSettingsForAccountAndProject(accountId: number, projectId: number, projectNotificationSetting: Array<ProjectNotificationSetting>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateNotificationsSettingsForAccountAndProject(accountId, projectId, projectNotificationSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific project by project ID
     * @param {number} projectId The numeric ID of a Project
     * @param {UpdateProjectRequest} [updateProjectRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateProject(projectId: number, updateProjectRequest?: UpdateProjectRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateProject(projectId, updateProjectRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



