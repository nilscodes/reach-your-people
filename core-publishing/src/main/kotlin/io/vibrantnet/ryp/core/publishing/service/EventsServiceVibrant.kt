package io.vibrantnet.ryp.core.publishing.service

import io.ryp.cardano.model.EventNotification
import io.ryp.cardano.model.EventNotificationType
import io.ryp.shared.model.AnnouncementJobDto
import io.ryp.shared.model.AnnouncementType
import io.ryp.shared.model.BasicAnnouncementWithIdDto
import org.springframework.amqp.rabbit.annotation.RabbitListener
import org.springframework.amqp.rabbit.core.RabbitTemplate
import org.springframework.data.redis.core.RedisTemplate
import org.springframework.stereotype.Service
import reactor.core.publisher.Mono
import java.util.*

@Service
class EventsServiceVibrant(
    private val redirectService: RedirectService,
    private val announcementsApiServiceVibrant: AnnouncementsApiServiceVibrant,
    private val rabbitTemplate: RabbitTemplate,
    private val redisTemplate: RedisTemplate<String, Any>,
    private val verifyService: VerifyService,
) {

    @RabbitListener(queues = ["event-notifications"])
    fun receiveMessage(eventNotification: EventNotification) {
        logger.info { "Received message: $eventNotification" }
        val announcementId = UUID.randomUUID()
        Mono.zip(
            redirectService.createShortUrlWithFallback("announcements/${announcementId}"),
            generateMetadata(eventNotification)
        )
            .flatMap { tuple ->
                val shortLink = tuple.t1
                val metadata = tuple.t2

                val announcementWithId = BasicAnnouncementWithIdDto(
                    id = UUID.randomUUID(),
                    type = AnnouncementType.fromEventType(eventNotification.type),
                    author = 0L,
                    title = "", // Title and content will be autogenerated based on metadata and type on the integration
                    content = "",
                    link = shortLink,
                    externalLink = "",
                    policies = eventNotification.audience.policies,
                    stakepools = eventNotification.audience.stakepools,
                    dreps = eventNotification.audience.dreps,
                    global = eventNotification.audience.global,
                    metadata = metadata,
                )
                announcementsApiServiceVibrant.createAnnouncement(announcementWithId, 0)
                    .map {
                        publishEventAnnouncement(announcementWithId)
                    }
            }.subscribe()
    }

    private fun generateMetadata(eventNotification: EventNotification): Mono<Map<String, String>> {
        return when (eventNotification.type) {
            EventNotificationType.GOVERNANCE_VOTE ->
                Mono.just(mapOf(
                    "drepId" to (eventNotification.audience.dreps.firstOrNull() ?: ""),
                    "poolHash" to (eventNotification.audience.stakepools.firstOrNull() ?: ""),
                    "transactionHash" to eventNotification.transactionHash,
                    "transactionIndex" to eventNotification.transactionIndex.toString(),
                    "comment" to (eventNotification.metadata["comment"] ?: ""),
                ))

            EventNotificationType.STAKEPOOL_RETIREMENT -> {
                val poolHash = eventNotification.audience.stakepools.first()
                verifyService.getStakepoolDetails(poolHash)
                    .onErrorResume { Mono.empty() } // Ignore all errors intentionally, as we don't want to fail the event notification if the pool details can't be fetched
                    .map {
                        mapOf(
                            "poolHash" to poolHash,
                            "transactionHash" to eventNotification.transactionHash,
                            "transactionIndex" to eventNotification.transactionIndex.toString(),
                            "poolName" to it.name,
                            "poolTicker" to it.ticker,
                        )
                    }.switchIfEmpty(Mono.just(mapOf("poolHash" to poolHash, "transactionHash" to eventNotification.transactionHash)))
            }
            EventNotificationType.GOVERNANCE_ACTION_NEW_PROPOSAL -> {
                Mono.just(mapOf(
                    "transactionHash" to eventNotification.transactionHash,
                    "transactionIndex" to eventNotification.transactionIndex.toString(),
                    "proposalType" to (eventNotification.metadata["type"] ?: ""),
                    "title" to (eventNotification.metadata["title"] ?: ""),
                ))
            }
            else -> Mono.just(emptyMap())
        }
    }

    private fun publishEventAnnouncement(
        announcement: BasicAnnouncementWithIdDto,
    ): Mono<Unit> {
        val announcementJob = AnnouncementJobDto(
            projectId = 0,
            announcementId = announcement.id,
            global = announcement.global,
        )

        logger.info { "Publishing event notification ${announcement.id} for event, publishing to policies: ${announcement.policies}, stakepools: ${announcement.stakepools}, dReps: ${announcement.dreps}, global: ${announcement.global}" }
        redisTemplate.opsForValue()
            .set("announcementsdata:${announcement.id}", announcement, 48, java.util.concurrent.TimeUnit.HOURS)
        rabbitTemplate.convertAndSend("announcements", announcementJob)
        return Mono.empty()
    }
}